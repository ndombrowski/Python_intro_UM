{
  "hash": "83cbb6c151f308d1f894000028f2a37d",
  "result": {
    "markdown": "# Functions\n\n## Build-in functions\n\nIn the context of programming, a function is a named sequence of statements that performs a computation. When you define a function, you specify the name and the sequence of statements.\n\nA function is some code we use. It takes some input and produces an output.\n\nWe have already seen one example of a function call:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\ntype(12)\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nint\n```\n:::\n:::\n\n\nThe name of the function is type. The expression in parentheses is called the **argument** of the function. The argument is a value or variable that we are passing into the function as input to the function. The result, for the type function, is the type of the argument.\n\nIt is common to say that a function takes an argument and returns a result. The result is called the **return value**.\n\n\n\n## Building functions\n\nSo far, we have only been using the functions that come with Python, but it is also possible to add new functions. A function definition specifies the name of a new function and the sequence of statements that execute when the function is called. Once we define a function, we can reuse the function over and over throughout our program.\n\n- We create a new function using the *def* keyword followed by optional parameters in parentheses\n- Below *say_sth()* is the name of the function\n- We indent the body of the function\n- The def statement only defines the function but does not execute the body of the function\n\nHere is an example:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n#write a function\ndef say_sth():\n    print('Hello')\n    print('Fun')\n\n#call/invoke the function\nsay_sth()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHello\nFun\n```\n:::\n:::\n\n\n### Arguments\n\n- An argument is a value we pass into the function as its input when we call the function\n- We can use arguments so we can direct the function to do different kinds of work when we call it at different times\n- We put the arguments in parenthesis after the name of the function\n\nLet's try this with a build-in function:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nmax('Hello world!')\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n'w'\n```\n:::\n:::\n\n\n### Parameters\n\nA parameter is a variable, i.e. an alias, which we use in the function definition. It is a handle that allows the code in the function to access the arguments for a particular function invocation.\n\nIn the example below *lang* is our alias for whatever first parameter is put in the function below:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef greet(lang):\n    if lang == 'es':\n        print('Hola')\n    elif lang == 'fr':\n        print('Bonjour')\n    else:\n        print('Hello')\n\ngreet('fr')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBonjour\n```\n:::\n:::\n\n\n### Return values\n\nOften a function will take its arguments, do some computations, and return a value to be used as the value of the function call in the **calling expression**. The **return** keyword is used for this:\n\nReturn does two things:\n\n- It stops the function and it jumps to the next line of code\n- It determines the residual value\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\ndef greet(lang):\n    if lang == 'es':\n        return 'Hola'\n    elif lang == 'fr':\n        return 'Bonjour'\n    else:\n        return 'Hello'\n\nprint(greet('es'), \"Glenn\")\nprint(greet('en'), \"Sally\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nHola Glenn\nHello Sally\n```\n:::\n:::\n\n\n### Using multiple parameters\n\n- We can define more than one parameter in the function definition\n- We simply add more arguments when we call the function\n- We match the number and order of arguments and parameters\n\nIn the example below *a,b* are parameters and *3,5* are arguments:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef addtwo(a,b):\n    added = a + b\n    return added\n\naddtwo(3,5)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n8\n```\n:::\n:::\n\n\n## Exercise\n\nWrite a program to prompt the user for hours and rate per hour using input to compute gross pay. Pay should be the normal rate for hours up to 40 and time-and-a-half for the hourly rate for all hours worked above 40 hours. Put the logic to do the computation of pay in a function called computepay() and use the function to do the computation. The function should return a value. Use 45 hours and a rate of 10.50 per hour to test the program (the pay should be 498.75). You should use input to read a string and float() to convert the string to a number. Do not worry about error checking the user input unless you want to - you can assume the user types numbers properly. Do not name your variable sum or use the sum() function.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ndef computepay(h,r):\n    if h > 40:\n        calc = (40 * r) + (h-40)*(r * 1.5)\n    else:\n        calc = h * r\n    return calc\n\n#get data\nhrs = input('Enter hours: \\n')\nrate = input('Enter rate: \\n')\n\n#convert to float\ntry:\n    hrs_f = float(hrs)\n    rate_f = float(rate)\nexcept:\n    print('Please, insert a number')\n    quit()\n\n#compute pay\np = computepay(hrs_f, rate_f)\n\nprint('Pay: ', p)\n```\n:::\n\n\n",
    "supporting": [
      "4_functions_files/figure-pdf"
    ],
    "filters": []
  }
}