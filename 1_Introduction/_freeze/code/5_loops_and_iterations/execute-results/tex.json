{
  "hash": "aefd161292a86929aff94ee53505caa5",
  "result": {
    "markdown": "# Loops and iteration\n\nLoops, i.e. repeated steps, have iteration variables that change each time through a loop.  \nOften these iteration variables go through a sequence of numbers\n\nIteration variable: Something that changes in the loop.\n\n## While keyword\n\nIn contrast to an if statement, which gives you once the possibility to do something or not (or something else), a while loop does things as long as the condition is true.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nn = 5\n\nwhile n > 0:\n    print(n)\n    n = n - 1\n\nprint(\"We have this number now:\", n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n4\n3\n2\n1\nWe have this number now: 0\n```\n:::\n:::\n\n\n## Infinite loops\n\nIn the example below, n is not changing and so the True can not become False and the loop with not stop running:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nn = 5\n\nwhile n > 0:\n    print('Hello')\n\nprint('We are done')\n```\n:::\n\n\n## The BREAK statement\n\n- The break statement is for breaking out of a loop\n- The break statement ends the current loop and jumps to the statement immediately following the loop\n- It is like a loop test that can happen anywhere in the body of the loop\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nwhile True:\n    line  = input('> ')\n    if line = 'done':\n        break\n    print(line)\n\nprint('We are out of the loop')\n```\n:::\n\n\n## The CONTINUE statement\n\nThe continue statement ends the current iteration and jumps to the top of the loop and starts the next iteration:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nwhile True:\n    line = input('> ')\n    if line[0] == '#':\n        continue\n    if line == 'done':\n        break\n    print(line)\n\nprint('We are out of the loop')\n```\n:::\n\n\n## Definite loops\n\nIndefinite loops that use the while keyword just run until some logical condition is false or you hit a break. In contrast, definite loops are finite and use the **for keyword**.\n\n### A simple for loop\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfor i in [5,4,3,2,1]:\n    print(i)\nprint('We are done')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n4\n3\n2\n1\nWe are done\n```\n:::\n:::\n\n\n- For: Our keyword for a finite loop\n- i: The iteration variable we set\n- a list of collection, i.e. a range of integers\n\n\n### Looking at `in`\n\n- The iteration variable (i.e. i) iterates through the sequence (ordered set, i.e. `[5,4,3,2,1]`)\n- The block (body, i.e. `print(i)`) of code is executed once for each value `in` the sequence\n- The iteration variable moves through all of the values in the sequence\n\n\n\n### A practical example: Finding the largest value\n\nProblem: Find the largest number in a range of number.\n\nIn the example below we make a variable that contains the largest value we have seen so far. If the current number we are looking at, the_num, is larger then it becomes the new largest value we have seen so far.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nlargest_so_far = -1\nprint('Before:', largest_so_far)\n\nfor the_num in [9, 41, 12,3, 74, 15]:\n    if the_num > largest_so_far:\n        largest_so_far = the_num\n    print(largest_so_far, the_num)\n\nprint('After:', largest_so_far)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore: -1\n9 9\n41 41\n41 12\n41 3\n74 74\n74 15\nAfter: 74\n```\n:::\n:::\n\n\n## Loop idioms\n\n### Counting things\n\nTo count how many times we execute a loop, we introduce a **counter variable** that starts at 0 and we add one to it each time we go through the loop.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\ncounter = 0\n\nprint('Before:', counter)\n\nfor num in [9,41,21,3,74,15]:\n    counter = counter + 1\n    print(counter, num)\n\nprint('After:', counter)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore: 0\n1 9\n2 41\n3 21\n4 3\n5 74\n6 15\nAfter: 6\n```\n:::\n:::\n\n\n### Summing in a loop\n\nTo add up a value we encounter in a loop, we introduce a **sum variable** that starts at 0 and we add the value to the sum each time through the loop.\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ncount = 0\n\nprint('Before:', count)\n\nfor num in [9,41,12,3,74,15]:\n    count = count + num\n    print(count, num)\n\nprint('After:', count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore: 0\n9 9\n50 41\n62 12\n65 3\n139 74\n154 15\nAfter: 154\n```\n:::\n:::\n\n\n### Summing in a loop\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\ncount = 0\nsum = 0\n\nprint('Before:', count, sum)\n\nfor value in [9,41,12,3,74,15]:\n    count = count + 1\n    sum = sum + value\n    print(count, sum, value)\n\nprint('After:', count, sum, sum/count)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore: 0 0\n1 9 9\n2 50 41\n3 62 12\n4 65 3\n5 139 74\n6 154 15\nAfter: 6 154 25.666666666666668\n```\n:::\n:::\n\n\n### Filtering in a loop\n\nWe use an if statement in the loop to catch/filter the values we are looking for:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nprint('Before')\n\nfor value in [9,41,12,3,74,15]:\n    if value > 20:\n        print('Large number', value)\n\nprint('After')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore\nLarge number 41\nLarge number 74\nAfter\n```\n:::\n:::\n\n\n### Searching using boolean variables\n\nIf we want to search and know if a value was found, we use a variable. I.e. below we want to ask if we can find the number 3.\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nfound = False\nprint('Before:', found)\n\nfor value in [9,41,12,3,74,15]:\n    if value == 3:\n        found = True\n    print(found, value)\n\nprint('After:', found)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore: False\nFalse 9\nFalse 41\nFalse 12\nTrue 3\nTrue 74\nTrue 15\nAfter: True\n```\n:::\n:::\n\n\nWe could speed things up using a break:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nfound = False\nprint('Before:', found)\n\nfor value in [9,41,12,3,74,15]:\n    if value == 3:\n        found = True\n        break\n    print(found, value)\n\nprint('After:', found)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore: False\nFalse 9\nFalse 41\nFalse 12\nAfter: True\n```\n:::\n:::\n\n\n### How to find the smallest value\n\nCompared to finding the largest number, the problem here is that we do not know with what value we have to start with, so the easiest is to not start with a number at all.\n\nWe still have a variable that is the smallest so far. The first time we go through the loop smallest is None, so we take the first value to be the smallest.\n\nNone is also called a flag value, a value that is priming us and get's us started.\n\nThe **is** and **is not** are operators that can be used in logical expression and implies *is the same as*.\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nsmallest = None\nprint('Before:', smallest)\n\nfor value in [9, 41, 12,3, 74, 15]:\n    if smallest is None:\n        smallest = value\n    elif value < smallest:\n        smallest = value\n    print(smallest, value)\n\nprint('After:', smallest)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBefore: None\n9 9\n9 41\n9 12\n3 3\n3 74\n3 15\nAfter: 3\n```\n:::\n:::\n\n\n## Excercise 1\n\nExercise 1: Write a program which repeatedly reads numbers until the user enters 'done'. Once 'done' is entered, print out the total, count,and average of the numbers. If the user enters anything other than a number, detect their mistake using try and except and print an error message and skip to the next number.\n\nCan be found in `code ask_number.py`\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nnum = 0\ntot = 0.0\n\nwhile True:\n    sval = input('Enter a number: ')\n    if sval == 'done':\n        break\n    try:\n        fval = float(sval)\n    except:\n        print('Invalid input. \\nEnter either a number or done')\n        continue\n    #print(fval)\n    num = num + 1\n    tot = tot + fval\n\n#print('All done')\nprint(tot, num, tot/num)\n```\n:::\n\n\n## Exercise 2\n\nWrite a program that repeatedly prompts a user for integer numbers until the user enters 'done'. Once 'done' is entered, print out the largest and smallest of the numbers. If the user enters anything other than a valid number catch it with a try/except and put out an appropriate message and ignore the number. Enter 7, 2, bob, 10, and 4 and match the output below.\n\nCode is in `ask_number2.py`.\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nlargest = None\nsmallest = None\n\nwhile True:\n    num = input('Enter a number: ')\n    if num == 'done':\n        break\n    try:\n        num_int = int(num)\n        if largest is None or num_int > largest:\n            largest = num_int\n        if smallest is None or num_int < smallest:\n            smallest = num_int\n    except:\n        print('Invalid input. \\nEnter either a number or done')\n        continue\n\nprint('Maximum is', largest)\nprint('Minimum is', smallest)\n```\n:::\n\n\n",
    "supporting": [
      "5_loops_and_iterations_files/figure-pdf"
    ],
    "filters": []
  }
}