{
  "hash": "7debe5b2a3fb708f026f840c1f7dd838",
  "result": {
    "markdown": "# Data models and relational SQL\n\n## Building a data model\n\n- Drawing a picture of the data objects for our application and then figuring out how to represent the objects and their relationships\n- Basic rule: Don't put the same string data in twice, use a relationship instead; i.e. don't use `Chuck` twice\n- When there is one thing in the \"real world\" there should be one copy of that thing in the database\n- If we build relational databases this reduces redundancy and makes things way faster compared to if we would put everything in a spreadsheet.\n\nThroughout this exercise, we want to build a database application listing track records and providing info such as track name, album, artist, genre, rating, song length, etc.  \n\nTo start drawing the relationships its good to start to think of what the most essential thing for the application is. I.e. here we want something that manages tracks --> so the first table we build is about the tracks and then ask what things are attributes of the track table and what things are tables themselves.  \n\nTable 1 would be the track table including the title, length, rating and counts.  \n\nNext, we ask what is connected to that table, i.e. we decide that tracks belong to albums, so we make a album table. Next, albums belong to groups, so another thing we need is a group/artist table.\n\nFinally, the question is what we do with the Genre? This will depend a bit on what we want to happen, if we change the genre of one thing. Do we want to only have a change for the track, for all the artists or all the albums?  In our case we only want to change it per track, so we say it belongs to the track table.\n\n\n## Definitions\n\n- **Primary key**: A way for us to refer to a particular row with a unique attribute/number. We use that number in a column in a different table to link tables up. The primary key uniquely identifies each record in a table. . Primary keys must contain UNIQUE values, and cannot contain NULL values. A table can have only ONE primary key; and in the table, this primary key can consist of single or multiple columns (fields). I.e. `id`\n- **Foreign key**: a field (or collection of fields) in one table, that refers to the PRIMARY KEY in another table. The table with the foreign key is called the child table, and the table with the primary key is called the referenced or parent table. I.e. `album_id`\n- **Logical key**: allows the DBMS Server or your application to assign a unique key value to each row in a table. I.e. a unique thing that we might use to look up this row from the outside world, such as an album title.\n\n<img width=500, src=\"../images/database_ex.png\">\n\n1. Open the SQLite browser\n2. Create a new `artist_db`\n3. File --> edit --> create table: Artist\n4. add field with id and INTEGER, click Not (Not null), click PK (primary key), click AI (auto increment, i.e. automatically add the id nrs)\n5. add new filed with: name, TEXT\n6. Press ok\n\nFor this we also see the code that is going to be used:\n\n```\nCREATE TABLE \"Artist\" (\n\t\"id\"\tINTEGER NOT NULL,\n\t\"name\"\tTEXT,\n\tPRIMARY KEY(\"id\" AUTOINCREMENT)\n);\n```\n\nWe can also create tables using code, i.e. lets do this with the genres table were we add the following code in the execute sql option.\n\nGenerally, **we create tables from outward to in** in order to generate the foreign keys so that we can link them in the final table.\n\n```\nCREATE TABLE Genre(\n    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\n    name TEXT\n)\n```\n\nNow, we create the album table. This table has the first example for a foreign key named `artist_id`:\n\n```\nCREATE TABLE Album(\n    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\n    artist_id INTEGER,\n    title TEXT\n)\n```\n\nLet's create the final table, tracks:\n\n```\nCREATE TABLE Track(\n    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\n    title TEXT,\n    album_id INTEGER,\n    genre_id INTEGER,\n    len INTEGER, rating INTEGER, count INTEGER\n)\n```\n\nNow we are ready to insert some data. Notice, we don't enter an ID field, since we set it to auto increment:\n\n```\ninsert into Artist (name) values('Led Zepplin')\ninsert into Artist (name) values ('AC/DC')\n```\n\nNext, lets insert some data into genre. If we use the semicolon we can both commands at once.\n\n```\ninsert into Genre (name) values ('Rock'); \ninsert into Genre (name) values ('Metal')\n```\n\nNext, lets do the album, the first example were we have a foreign key. The two for `who made who` links to AC/DC in our Artist table and we have to make sure that we get this right.\n\nAt the moment this is hard to do by hand but we later will write a program to do this.\n\n```\ninsert into Album (title, artist_id) values ('Who Made Who', 2);\ninsert into Album (title, artist_id) values ('IV', 1)\n```\n\nThe last table to add is the tracks one. Here, we have some replications since some tracks belong to the same album. \n\n```\ninsert into Track (title, rating, len, count, album_id, genre_id) values ('Black Dog', 5,297, 0, 2, 1);\n\ninsert into Track (title, rating, len, count, album_id, genre_id) values ('Stairway', 5,482, 0, 2, 1);\n\ninsert into Track (title, rating, len, count, album_id, genre_id) values ('About to Rock', 5,313, 0, 1, 2);\n\ninsert into Track (title, rating, len, count, album_id, genre_id) values ('Who Made Who', 5,207, 0, 1, 2);\n```\n\n\n## Relational power\n\n- By removing the replicated data and replacing it with references to a single copy of each bit of data, we build a \"web\" of information that the relational database can read through very quickly, even for large amounts of data\n- Often when you want some data that comes from a number of tables we can link these by their foreign keys\n\n\n## The join operation\n\n- The join operation links several tables as part of a select operation\n- You must tell the join how to use the keys that make the connection between the tables using an `ON clause`\n\n```\nselect Album.title, Artist.name from Album\njoin Artist on Album.artist_id = Artist.id\n```\n\nHere, we say:\n\n- What column we want to see and from what table it comes: `Album.title, Artist.name`\n- The tables that hold the data: `from Album join Artist`\n- How the tables are linked = `Album.artist_id = Artist.id`\n- With the join we make a super table out of two tables\n- If we would not add an on clause, this would give us all combinations of the two tables. The on clause is basically only giving us things that match\n\nNext, let's extract the tracks title and genre name:\n\n```\nselect Track.title, Genre.name from Track\njoin Genre on Track.Genre_id = Genre.id\n```\n\nWe can also go more complex and combine more than 2 tables.\n\n```\nselect Track.title, Artist.name, Album.title, Genre.name from\nTrack join Genre join Album join Artist on\nTrack.genre_id = Genre.id and\nTrack.album_id = Album.id and\nAlbum.artist_id = Artist.id\n```\n\n\n## Generating a db with python\n\nCode can be found in `code/track_db.py`\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nimport xml.etree.cElementTree as ET\nimport sqlite3\n\n#make a db connection\nconn = sqlite3.connect('trackdb.sqlite')\ncur = conn.cursor()\n\n#make some fresh tables\ncur.executescript('''\nDROP TABLE IF EXISTS Artist;\nDROP TABLE IF EXISTS Album;\nDROP TABLE IF EXISTS Track;\n\nCREATE TABLE Artist (\n    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\n    name TEXT UNIQUE\n);\n\nCREATE TABLE Album (\n    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, \n    artist_id INTEGER,\n    title TEXT UNIQUE\n);\n\nCREATE TABLE Track (\n    id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE, \n    title TEXT UNIQUE,\n    album_id INTEGER,\n    len INTEGER, rating INTEGER, count INTEGER\n);\n''')\n\n#get the data we will use to populate our tables\nfname = '../data/Library.xml'\n\n#the syntax for our data looks as follows\n# <key>Track ID</key><integer>369</integer>\n# <key>Name</key><string>Another One Bites The Dust</string>\n# <key>Artist</key><string>Queen</string>\n\n#lookup function that looks up the key for an object\ndef lookup(d, key):\n    found = False\n    for child in d:\n        if found: return child.text\n        if child.tag == 'key' and child.text == key:\n            found = True\n    return None\n\n#parse the filename string returning an xml object\nstuff = ET.parse(fname)\n\n#going into the 3rd dict levels gives us the tracks\n#so for each key id we want all the track information\nall = stuff.findall('dict/dict/dict')\nprint('Dict count', len(all))\n\n#extract data using the lookup function\nfor entry in all:\n    if ( lookup(entry, 'Track ID') is None ) : continue\n\n    name = lookup(entry, 'Name')\n    artist = lookup(entry, 'Artist')\n    album = lookup(entry, 'Album')\n    count = lookup(entry, 'Play Count')\n    rating = lookup(entry, 'Rating')\n    length = lookup(entry, 'Total Time')\n\n    if name is None or artist is None or album is None : \n        continue\n\n    #print(name, artist, album, count, rating, length)\n\n    #populate our tables\n    #INSERT OR INGORE says only put row if text is not there\n    #only works since when we generate the table with `name TEXT UNIQUE`\n    cur.execute('''INSERT OR IGNORE INTO Artist (name)\n        VALUES (?)''', (artist,))\n    cur.execute('SELECT id FROM Artist WHERE name = ?', (artist,))\n    artist_id = cur.fetchone()[0]\n\n    #since artist_id is the foreign id for the album title, then we can deal with the next table\n    cur.execute('''INSERT OR IGNORE INTO Album (title, artist_id)\n        VALUES(?, ?)''', (album, artist_id))\n    cur.execute('SELECT id FROM Album WHERE title = ?', (album,))\n    album_id = cur.fetchone()[0]\n\n    cur.execute('''INSERT OR REPLACE INTO Track\n        (title, album_id, len, rating, count) \n        VALUES ( ?, ?, ?, ?, ? )''', \n        ( name, album_id, length, rating, count ) )\n\n    conn.commit()\n\nprint('DB created successfully')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDict count 404\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nDB created successfully\n```\n:::\n:::\n\n\nWe can check if this worked by looking at it in the SQL browser, i.e.\n\n```\nSELECT Track.title, Album.title, Artist.name FROM Track\nJOIN Album JOIN Artist ON Track.album_id = Album.id AND Album.artist_id = Artist.id\n```\n\n## Exercise \n\nIn this assignment you will parse an XML list of albums, artists, and Genres and produce a properly normalized database using a Python program.\n\nThis application will read an iTunes export file in XML and produce a properly normalized database with this structure by using the library xml file:\n\n```\nCREATE TABLE Artist (\n    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\n    name    TEXT UNIQUE\n);\n\nCREATE TABLE Genre (\n    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\n    name    TEXT UNIQUE\n);\n\nCREATE TABLE Album (\n    id  INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT UNIQUE,\n    artist_id  INTEGER,\n    title   TEXT UNIQUE\n);\n\nCREATE TABLE Track (\n    id  INTEGER NOT NULL PRIMARY KEY \n        AUTOINCREMENT UNIQUE,\n    title TEXT  UNIQUE,\n    album_id  INTEGER,\n    genre_id  INTEGER,\n    len INTEGER, rating INTEGER, count INTEGER\n);\n```\n\nCode is found in `code/exercise_tracks.py`\n\n",
    "supporting": [
      "3_data_models_and_relational_sql_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}