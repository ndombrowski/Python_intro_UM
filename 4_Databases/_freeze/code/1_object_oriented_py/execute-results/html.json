{
  "hash": "dccec188a75c94b402ee7f8061e03e34",
  "result": {
    "markdown": "# Object oriented Python\n\n## Definitions\n\n- **Class**: A template, a shape of an object, i.e. a string is a class. A class defines the abstract characteristics of a thing (object) including the things characteristics (its attributes, fields or properties) and the things behaviors (the things it can do or methods).\n- **Method** or Message: A defined capability of a class; an objects abilities.\n- Field or **attribute**: A bit of data in a class\n- **Object** or instance: A particular instance of a class. I.e. in `x='abc'` x is the object.\n- Constructor: Code that runs when an object is created\n- Inheritance: The ability to extend a class to make a new class\n\n\n## Object oriented\n\n- A program is made up of many cooperating objects\n- Instead of being the \"whole program\", each object is a little \"island\" within the program and cooperatively working with other objects\n- A program is made up of one or more objects working together, objects make use of each others capabilities\n\n\n## Objects\n\n- An object is a bit of self-contained code and data\n- A key aspect of the Object approach is to break the problem into smaller, understandable parts (divide and conquer)\n-Objects have boundaries that allow us to ignore un-needed detail\n- We have been already using objects: String objects, integer objects, dictionary objects, list objects ...\n- Objects hide detail, they allow the \"rest of the program\" to ignore the detail\n\n\n## Building our own class\n\n- Class is a reserved word\n- Each 'PartyAnimal' object has a bit of code\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n#make an object with a bit of data in it\nclass PartyAnimal:\n    x = 0\n    \n    # add a bit of code\n    #self is used to refer to the instance in which the method is being called\n    def party(self):\n        self.x = self.x + 1\n        print('So far', self.x)\n\n#construct a PartyAnimal object, an, and store it in a variable\n#same as `x = list()`\n#this makes an an alias to self , which gets used in the method above\nan = PartyAnimal()\n\n#tell the object to run the party() code within it\n#i.e. invoke methods inside an object\n#this basically does this: PartyAnimal.party(an)\nan.party()\nan.party()\nan.party()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSo far 1\nSo far 2\nSo far 3\n```\n:::\n:::\n\n\n- The `dir()` command lists the capabilities of an object\n- In the output, ognore the ones with underscores, these are used by python itself\n- The rest are real operations that the object can perform\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\ntype(an)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n__main__.PartyAnimal\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\ndir(an)\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\n['__class__',\n '__delattr__',\n '__dict__',\n '__dir__',\n '__doc__',\n '__eq__',\n '__format__',\n '__ge__',\n '__getattribute__',\n '__gt__',\n '__hash__',\n '__init__',\n '__init_subclass__',\n '__le__',\n '__lt__',\n '__module__',\n '__ne__',\n '__new__',\n '__reduce__',\n '__reduce_ex__',\n '__repr__',\n '__setattr__',\n '__sizeof__',\n '__str__',\n '__subclasshook__',\n '__weakref__',\n 'party',\n 'x']\n```\n:::\n:::\n\n\n## Object lifecycle\n\n- Objects are created, used and discarded\n- We have special blocks of code (methods) that get called:\n    - At the moment of creation = constructor\n    - At the moment of destruction = destructor\n- Constructors are used a lot\n- Destructors are seldom used\n- The constructor and destructor are optional. \n- The constructor is typically used to set up variables.\n\n\n## Constructor\n\n- The primary purpose of the constructor is to set up some instance variables to have the proper initial values when the object is created\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n#make an object with a bit of data in it\nclass PartyAnimal:\n    x = 0\n    \n    def __init__(self):\n        print('I am constructed')\n        \n    def party(self):\n        self.x = self.x + 1\n        print('So far', self.x)\n    \n    def __del__(self):\n        print('I am destructed', self.x)\n        \nan = PartyAnimal()  \n\nprint(an.party())\nprint(an.party())\n\n#if we run step by step, then we get the destruction call here\nan = 42\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nI am constructed\nSo far 1\nNone\nSo far 2\nNone\nI am destructed 2\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nprint('an contains', an)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nan contains 42\n```\n:::\n:::\n\n\n## Many **Instances**\n\n- We can create lots of objects, the class is the template for the object\n- We can store each distinct object in its own variable\n- We call this having multiple instances of the same class\n- Each instance has its own copy of the instance variables\n\nConstructors, i.e. def__init__, can have additional parameters, i.e. z. These can be used to setup instance variables, i.e. name or self.name, for the particular instance of the class.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nclass PartyAnimal:\n    x = 0\n    name = \"\"\n    \n    def __init__(self, z):\n        self.name = z\n        print(self.name, \"constructed\")\n    \n    def party(self):\n        self.x = self.x + 1\n        print(self.name, \"party count\", self.x)\n\n#make me an object, with Sally as a parameter\ns = PartyAnimal(\"Sally\")\ns.party()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSally constructed\nSally party count 1\n```\n:::\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n#make another template\n#this creates a second, independent, instance\nj = PartyAnimal(\"Jim\")\nj.party()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJim constructed\nJim party count 1\n```\n:::\n:::\n\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ns.party()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSally party count 2\n```\n:::\n:::\n\n\n## Object inheritance\n\n- When we make a new class, we can reuse an existing class and inherit all the capabilities of an existing class and then add our own little bit to it to make our new class\n- This is another form of store and reuse\n- Write once, reuse many times\n- The new class (child) has all the capabilities of the old class (parent) and then some more\n- \"Subclasses\" are a more specialized version of a class, which inherit attributes and behaviors from their parent classes and can introduce their own\n\n\nBelow FootballFan is a class which extends PartyAnimal. It has all the capabilities of PartyAnimal and more.\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nclass PartyAnimal:\n    x = 0\n    name = \"\"\n    \n    def __init__(self, name):\n        self.name = name\n        print(self.name, \"constructed\")\n        \n    def party(self):\n        self.x = self.x + 1\n        print(self.name, \"party count\", self.x)\n    \n#create a new class extending PartyAnimal\nclass FootballFan(PartyAnimal):\n    points = 0\n    \n    def touchdown(self):\n        self.points = self.points + 7\n        self.party()\n        print(self.name, \"points\", self.points)\n\ns = PartyAnimal('Sally')\ns.party()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSally constructed\nSally party count 1\n```\n:::\n:::\n\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nj = FootballFan('Jim')\nj.party()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJim constructed\nJim party count 1\n```\n:::\n:::\n\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nj.touchdown()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nJim party count 2\nJim points 7\n```\n:::\n:::\n\n\n",
    "supporting": [
      "1_object_oriented_py_files"
    ],
    "filters": [],
    "includes": {}
  }
}