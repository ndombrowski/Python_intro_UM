{
  "hash": "1caefe2d32ff81371ed6aec44a68c367",
  "result": {
    "markdown": "# Web services and XML\n\n\n## Data on the web\n\n- With the HTTP request/response well understood and supported, there was a natural move towards exchanging data between programs and these protocols\n- We needed to come up with up with an agreed way to represent data going between applications and across networks\n- Two commonly used formats are XML and JSON\n\n\n## eXtensible Markup Language (XML)\n\n- Primary purpose is to help information systems share structured data\n- It started as a simplified subset of the Standard Generalized Markup Language (SGML) and is designed to relatively human-legible\n- Consists of XML elements (or nodes) that have start and end tags in between smaller greater signs, i.e. <people>\n- Contains simple and complex elements\n\n\n### XML terminology\n\n- **Tags** indicate the beginning and the ending of elements\n- **Attributes** are keyword/value pairs on the opening tag of XML\n- **Serialize and De-serialize** convert data in one program into a common format that can be stored and/or transmitted between systems in a programming language-independent manner\n\n\n### The XML tree structure\n\n- XML documents form a tree structure that starts at \"the root\" and branches to \"the leaves\".\n- XML documents are formed as element trees.\n- An XML tree starts at a root element and branches from the root to child elements.\n- All elements can have sub elements (child elements):\n\n```\n<root>\n  <child>\n    <subchild>.....</subchild>\n  </child>\n</root>\n```\n\n- The terms parent, child, and sibling are used to describe the relationships between elements.\n- Parents have children. Children have parents. Siblings are children on the same level (brothers and sisters).\n\n<img width=500 src=\"../images/xml_tree.png\">\n\n\n### XML basics\n\n- The difference to HTML is that we can create our own tags\n- Start Tag, i.e. <name>\n- End tag, i.e. </name>\n- Text content, i.e. Chuck\n\nTogether we can make a simple element like this:\n\n```\n<name>Chuck</name>\n```\n\n- Attribute, i.e. type \"intl\"\n\n```\n<phone type=\"intl\">\n+1 734 303 4456\n</phone>\n```\n\n- Self closing tag incl. an attribute i.e. `<email hide=\"yes\" />`\n\n\n### White space\n\nLine ends don't really matter in XML,  \nWhite space is generally discarded on text elements.  \nWe indent only to be readable.\n\n\n### XML schema\n\n- Describing a \"contract\" as to what is acceptable in XML\n- Description of the legal format of an XML document\n- Expressed in terms of constraints on the structure and content of documents\n- Often used to specify a \"contract\" between systems: I.e. my system will only accept XML that confirms to this particular schema\n- If a particular piece of XML meets the specification of the schema, then it is said to **validate**\n\n\n### Many XML schema languages\n\n- Document type definition (DTD)\n- Standard Generalized Markup language (ISO 8879:1986 SGML)\n- XML schema for W3C (XSD), the most likely one we encounter\n\n\n### ISO 8601 Date/Time format\n\n```\n2002-05-30T09:30:10Z\n```\n\nAbove we have:\n\n- Year-month-date\n- Time of the day\n- Time zone (i.e.T...Z), which typically is specified in UTC/GMT rather than a local time zone\n\n\n## Parsing XML in python\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n#Use ET as an alias so we don't have to write the whole thing\nimport xml.etree.ElementTree as ET\n\n#create some xml\n#tripple quoted string = multiline string in python\ndata = '''<person>\n    <name>Chuck</name>\n    <phone type=\"intl\">+1 734 303 4456</phone>\n    <email hide=\"yes\"/>\n    </person>'''\n\n#take the string data and give us back a nice tree\n#this would fail if you have syntax errors\ntree = ET.fromstring(data)\n\n#within that xml data find some tags, i.e. name,\n#and extract the text\nprint('Name:', tree.find('name').text)\n\n#within that xml data find some tags, i.e. email\n#and get the attribute hide using the get method\nprint('Attr:', tree.find('email').get('hide'))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nName: Chuck\nAttr: yes\n```\n:::\n:::\n\n\nThis works a bit differently if we have multiple child tags, i.e. below we want to extract information for each of these user tags:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nimport xml.etree.ElementTree as ET\n\ninput = '''\n<stuff>\n  <users>\n    <user x=\"2\">\n      <id>001</id>\n      <name>Chuck</name>\n    </user>\n    <user x=\"7\">\n      <id>009</id>\n      <name>Brent</name>\n    </user>\n  </users>\n</stuff>'''\n\n#get tree\nstuff = ET.fromstring(input)\n\n#search for all of the user tags below users\n#this gives us a list of tags (i.e. a list of subtrees)\nlst = stuff.findall('users/user')\nprint('User count:', len(lst))\nprint('')\n\n#loop through the list to get the info we want\n#i.e. find the tag name and get the child text\nfor item in lst:\n    print('Name:', item.find('name').text)\n    print('ID:', item.find('id').text)\n    print('Attribute:', item.get('x'))\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nUser count: 2\n\nName: Chuck\nID: 001\nAttribute: 2\nName: Brent\nID: 009\nAttribute: 7\n\n```\n:::\n:::\n\n\n## Extracting Data from XML\n\nIn this assignment you will write a Python program somewhat similar to https://py4e.com/code3/geoxml.py.  \n\nThe program will prompt for a URL, read the XML data from that URL using urllib and then parse and extract the comment counts from the XML data, compute the sum of the numbers in the file and enter the sum.\n\nWe provide two files for this assignment. One is a sample file where we give you the sum for your testing and the other is the actual data you need to process for the assignment.\n\n- Sample data: http://py4e-data.dr-chuck.net/comments_42.xml (Sum=2553)\n- Actual data: http://py4e-data.dr-chuck.net/comments_1701461.xml (Sum ends with 75)\n\nYou do not need to save these files to your folder since your program will read the data directly from the URL.\n\nThe data consists of a number of names and comment counts in XML as follows:\n\n```\n<comment>\n  <name>Matthias</name>\n  <count>97</count>\n</comment>\n```\n\nYou are to look through all the <comment> tags and find the <count> values sum the numbers. \n\nTo make the code a little simpler, you can use an XPath selector string to look through the entire tree of XML for any tag named 'count' with the following line of code:\n\n```\ncounts = tree.findall('.//count')\n```\n\nCode can be found in `code/extract_xml.py`\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nimport urllib.request, urllib.parse, urllib.error\nimport xml.etree.ElementTree as ET\nimport ssl\n\n# Ignore SSL certificate errors\nctx = ssl.create_default_context()\nctx.check_hostname = False\nctx.verify_mode = ssl.CERT_NONE\n\n#read in data\nurl = 'http://py4e-data.dr-chuck.net/comments_1701461.xml'\ninput = urllib.request.urlopen(url, context=ctx)\ndata = input.read()\n\nstuff = ET.fromstring(data)\n\n#find comments\nlst = stuff.findall('comments/comment')\n#print('Comment count:', len(lst))\n\n#extract numbers:\nnum_list = list()\n\nfor item in lst:\n    num = int(item.find('count').text)\n    num_list.append(num)\n\nprint('Sum:', sum(num_list))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSum: 2375\n```\n:::\n:::\n\n\n",
    "supporting": [
      "5_web_services_and_xml_files"
    ],
    "filters": [],
    "includes": {}
  }
}