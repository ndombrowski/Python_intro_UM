{
  "hash": "886dd06234f21caff5763eac9f0123e1",
  "result": {
    "markdown": "# Regular expressions\n\n## Definition\n\nIn computing a regular expression, also referred to as regex or regexp, provides a concise and flexible means for matching strings of text, such as particular characters, words or patterns of characters.  \n\nA regular expression is written in a formal language that can be interpreted by a regular expression processor.  \n\nIt allows to use \"wild card\" expressions for matching and parsing strings.  \n\n<img width = 600 src=\"../images/reg_exp.png\">\n\n\n## The regular expression module\n\n- Before you can use regular expressions in python, you most import the library using `import re`\n- You can use `re.search()` to see if a string matches a regular expression, similar to using the find() method for strings\n- You can use `re.findall()` to extract positions of a string that match your regular expression, similar to using a combination of find() and slicing.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n#import lib\nimport re\n```\n:::\n\n\nBefore we did:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nhand = open('../data/mbox-short.txt')\n\nfor line in hand:\n    line = line.rstrip()\n    if line.find('From: s') >=0 :\n        print(line)\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrom: stephen.marquard@uct.ac.za\nFrom: stephen.marquard@uct.ac.za\n\n```\n:::\n:::\n\n\nBut instead we could use a regular expression:\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nhand = open('../data/mbox-short.txt')\n\nfor line in hand:\n    line = line.rstrip()\n    if re.search('From: s', line):\n        print(line)\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrom: stephen.marquard@uct.ac.za\nFrom: stephen.marquard@uct.ac.za\n\n```\n:::\n:::\n\n\nUse a regular expression instead of startswith(). Here , we fine tune what is matched by adding special characters to the string, i.e. `^`\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nhand = open('../data/mbox-short.txt')\n\nfor line in hand:\n    line = line.rstrip()\n    if re.search('^From: s', line):\n        print(line)\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFrom: stephen.marquard@uct.ac.za\nFrom: stephen.marquard@uct.ac.za\n\n```\n:::\n:::\n\n\n## Wildcard characters\n\n- The dot character matches any character\n- If you add the asterisk character, the character is \"any number of times\", i.e. 0 or more times\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nhand = open('../data/mbox-short.txt')\n\nlst = list()\nfor line in hand:\n    line = line.rstrip()\n    if re.search('^X-.*:', line):\n        if line not in lst:\n            lst.append(line)\n\nfor i in lst[:4]:\n    print(i)\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nX-Sieve: CMU Sieve 2.3\nX-Authentication-Warning: nakamura.uits.iupui.edu: apache set sender to stephen.marquard@uct.ac.za using -f\nX-Content-Type-Outer-Envelope: text/plain; charset=UTF-8\nX-Content-Type-Message-Body: text/plain; charset=UTF-8\n\n```\n:::\n:::\n\n\nWe can also be more specific and find everything starting with `X-` then match any non-whitespace character `/S` one or more times `+` . This would discard any hits that have any whitespace between the X- and the colon.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nhand = open('../data/mbox-short.txt')\n\nlst = list()\nfor line in hand:\n    line = line.rstrip()\n    if re.search('^X-\\S+:', line):\n        if line not in lst:\n            lst.append(line)\n\nfor i in lst[:5]:\n    print(i)\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nX-Sieve: CMU Sieve 2.3\nX-Authentication-Warning: nakamura.uits.iupui.edu: apache set sender to stephen.marquard@uct.ac.za using -f\nX-Content-Type-Outer-Envelope: text/plain; charset=UTF-8\nX-Content-Type-Message-Body: text/plain; charset=UTF-8\nX-DSPAM-Result: Innocent\n\n```\n:::\n:::\n\n\n## `re.findall()`\n\n- `re.search()` returns a True/False depending on whether the string matches the regular expression\n- If we actually want the matching strings to be extracted, we use `re.findall()``\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nx = 'My 2 favorite numbers are 19 and 420'\ny = re.findall('[0-9]+', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['2', '19', '420']\n```\n:::\n:::\n\n\nHere: `[0-9]+` Looks for any number between 0-9 and the plus indicates that we look for one or more digits.\n\nNotice: This gives us a list with three strings, not numbers. If there is no match, we get back an empty list:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nx = 'My 2 favorite numbers are 19 and 420'\ny = re.findall('[AEIOU]+', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[]\n```\n:::\n:::\n\n\n## Greedy matching\n\nThe repeat characters (* and +) push outward in both directions (greedy) to match the largest possible string:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nx = 'From: Using the : character'\ny = re.findall('F.+:', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['From: Using the :']\n```\n:::\n:::\n\n\nWhy in the example we don't only get `From:` ?\n\nBecause we ask for a pattern, where the first character in the match is an F followed by one or more characters and ending with a colon. Then we get the largest possible string, which is not what we actually are looking for.  \n\n\n## Non-greedy matching\n\nNot all regular expression repeat codes are greedy!  \nIf you add a `?` character, the + and * chill out a bit...\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nx = 'From: Using the : character'\ny = re.findall('F.+?:', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['From:']\n```\n:::\n:::\n\n\nHere, we ask for a pattern, where the first character in the match is an F followed by one or more characters that are not greedy and ending with a colon. \n\n\n## Fine-tuning string extraction\n\nIf we refine the match for `re.findaa()` and separately determine which proportion of the match is to be extracted by using parentheses:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nx = 'From stephen.marquard@uct.ac.za Sat Jan  4 09:14:16 2008'\n\ny = re.findall('\\S+@\\S+', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['stephen.marquard@uct.ac.za']\n```\n:::\n:::\n\n\nHere, we find everything that matches one or more blank characters followed by an @ sign followed by one or more non-blank characters. \n\nHere, we need greedy matching to not only be left with a *d@u*.  \n\nParentheses are not part of the match, but they tells where to start and stop what string to extract:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nx = 'From stephen.marquard@uct.ac.za Sat Jan  4 09:14:16 2008'\n\ny = re.findall('^From (\\S+@\\S+)', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['stephen.marquard@uct.ac.za']\n```\n:::\n:::\n\n\nI.e. above our search statement looks for pattern starting with a *From* followed by a space, followed by one or more matching our non-blank characters but the *From* is not printed, only everything between parentheses is.  \n\nI.e. we tell python to start extracting AFTER `From `. \n\n\n## Double split patterns\n\nSometimes we split a line one way and then grep one of the pieces in the line and split that piece again:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\nx = 'From stephen.marquard@uct.ac.za Sat Jan  4 09:14:16 2008'\n\n#y = re.findall('@(\\S+)', x)\ny = re.findall('@([^ ]*)', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['uct.ac.za']\n```\n:::\n:::\n\n\nHere, we look for a pattern that start with an @sign followed by a number of non-blank characters.\n\n- `[^ ]` : Match non-blank character, i.e starting with a `^` inside the brackets means NOT --> match everything that is NOT a space\n- `[^ ]*`:  Match many non-blank characters\n\nSome fine-tuning:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nx = 'From stephen.marquard@uct.ac.za Sat Jan  4 09:14:16 2008'\n\n#y = re.findall('@(\\S+)', x)\ny = re.findall('^From .*@([^ ]*)', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['uct.ac.za']\n```\n:::\n:::\n\n\n## Escape character\n\nIf you want a special regular expression character to just behave normally you prefix it with `\\`\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nx = 'We just received $10.00 for cookies'\n\ny = re.findall('\\$[0-9.]+', x)\nprint(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['$10.00']\n```\n:::\n:::\n\n\n## Using regex example\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nimport re\n\nhand = open('../data/mbox-short.txt')\nnumlist = list()\n\nfor line in hand:\n    line = line.rstrip()\n    #extract what we are interest in\n    stuff = re.findall('^X-DSPAM-Confidence: ([0-9.]+)', line)\n    \n    #deal with IndexError: list index out of range\n    #since we know stuff should be a list with one element in there\n    if len(stuff) != 1:\n        continue\n    \n    #extract pattern and convert to float\n    num = float(stuff[0])\n    \n    #add all numbers to lists\n    numlist.append(num)\n\nprint('Maximum: ', max(numlist))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaximum:  0.9907\n```\n:::\n:::\n\n\n## Exercise\n\nIn this assignment you will read through and parse a file with text and numbers. You will extract all the numbers in the file and compute the sum of the numbers.\n\nThe basic outline of this problem is to read the file, look for integers using the re.findall(), looking for a regular expression of '[0-9]+' and then converting the extracted strings to integers and summing up the integers.\n\nCode found in `code/count_numbers.py`\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nhandle = open('../data/regex_sum_1701457.txt')\n\nimport re\n\nnumlst = list()\ncounter = 0\n\nfor line in handle:\n    line = line.rstrip()\n\n    #extract list of numbers\n    num = re.findall('[0-9]+', line)\n    if len(num) == 0:\n        continue\n\n    #add numbers to list\n    numlst = numlst + num\n\n#convert to strings\nfor i in range(0, len(numlst)):\n    numlst[i] = int(numlst[i])\n\nprint(sum(numlst))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n383660\n```\n:::\n:::\n\n\n",
    "supporting": [
      "2_reg_expressions_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}