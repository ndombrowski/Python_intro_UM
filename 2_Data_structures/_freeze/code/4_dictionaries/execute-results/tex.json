{
  "hash": "b1f26ec1853b0e662b478500080f4120",
  "result": {
    "markdown": "# Dictionaries\n\n## Introduction\n\n- Dictionaries are a type of data collection\n- Dictionaries are \"bags\" of values, each with its own label\n- Its an associative array: an abstract data type that stores a collection of (key, value) pairs, such that each possible key appears at most once in the collection\n- Dictionaries allow us to do fast database-like operations\n\n- Dictionaries list their entries based on the position in the list\n- There is no order in dictionary, in contrast to lists\n- Instead we index things we put in the dictionary with a \"look up tag\", i.e. a **key**\n- Contents are mutable/changable\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\n#create an empty dictionary object\npurse = dict()\n\n#create  key (ie money) - value (ie 12) pairs\npurse['money'] = 12\npurse['candy'] = 3\npurse['tissues'] = 75\n\nprint(purse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'money': 12, 'candy': 3, 'tissues': 75}\n```\n:::\n:::\n\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\n#extract sth from a dict using the key\npurse['candy']\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n3\n```\n:::\n:::\n\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\n#manipulate one entry\npurse['candy'] = purse['candy'] + 2\nprint(purse)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'money': 12, 'candy': 5, 'tissues': 75}\n```\n:::\n:::\n\n\n## Dictionary literals (constants)\n\n- Dictionaries literals use curly braces and have a list of key:value pairs\n- You can make an empty dictionary using empty curly braces\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\n#here, the dictionary constant gets assigned to jjj\njjj = {'chuck':1, 'fred':42, 'jan':100}\nprint(jjj)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'chuck': 1, 'fred': 42, 'jan': 100}\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nooo = {}\nprint(ooo)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{}\n```\n:::\n:::\n\n\n## Dictionary tracebacks\n\n- We will get a traceback error if we reference a key which is not in the dictionary\n- We can use an in operator to see if a key is in the dictionary\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\n#the code below would give an error\nccc = dict()\nprint(ccc['csev'])\n```\n:::\n\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\n#make a dict\nccc = dict()\n\n#check for a key\n'csev' in ccc\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nFalse\n```\n:::\n:::\n\n\n## Counting with dictionaries\n\n- One common use of dictionaries is counting how often we \"see\" something.  \n- When we encounter a new name, we need to add a new entry to the dictionary and if this is the second or later time we have seen the name, we simply add one to the count in the dictionary under that name\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\ncounts = dict()\nnames = ['csev', 'cwen', 'csev', 'zqian', 'cwen']\n\nfor name in names:\n    if name not in counts:\n        counts[name] = 1\n    else:\n        counts[name] = counts[name] + 1\n\nprint(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'csev': 2, 'cwen': 2, 'zqian': 1}\n```\n:::\n:::\n\n\n## Counting with the get method for dictionaries\n\nThe pattern of checking to see if a key is already in a dictionary and assuming a default value if the key is not there is so common that there is a method called `get()` that does it for us.\n\nIf the key does not exist, we get a default value, so we don't get a traceback.\n\nLet's walk through this \n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\n#counts = dict()\n#names = ['csev', 'cwen', 'csev', 'zqian', 'cwen']\n\nif name in counts:\n    x = counts[name]\nelse: \n    x = 0\n\nprint(counts)\n\n#below, 0 is the default that is used if the key is not yet in a dictionary\nx = counts.get(name, 0)\nprint(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'csev': 2, 'cwen': 2, 'zqian': 1}\n2\n```\n:::\n:::\n\n\nClean, this code looks like this:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\ncounts = dict()\nnames = ['csev', 'cwen', 'csev', 'zqian', 'cwen']\n\nfor name in names:\n    counts[name] = counts.get(name, 0) + 1\n\nprint(counts)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'csev': 2, 'cwen': 2, 'zqian': 1}\n```\n:::\n:::\n\n\n## Counting text lines\n\nLets start simple and count the words in a line.\n\nThe general pattern to count the words in a line of text is to split the line into words, then loop through the words and use a dictionary to track the count of each word independenly.\n\nThe running code can be found in `code/count_text_line.py`\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\ncounts = dict()\n\nprint('Enter a line of text: ')\nline = input('')\n\nwords = line.split()\n\nprint('We have these words: ', words)\n\nprint('Counting...')\nfor word in words:\n    counts[word] = counts.get(word, 0) + 1\n\nprint('Counts: ', counts)\n```\n:::\n\n\n## Definite loops and dictionaries\n\nEven though dictionaries are not stored in order, we can write a for loop that goes through all the entries in a dictionary; actually it goes through all of the keys in a dictionary and looks up the values\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\ncounts = {'chuck':1, 'fred':42, 'jan':100}\n\n#here 'key' takes on the successive values for the keys not the values\nfor key in counts:\n    print(key, counts[key])\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nchuck 1\nfred 42\njan 100\n\n```\n:::\n:::\n\n\n## Retrieving lists of keys and values\n\nYou can get a list of keys, values or items (both) from a dictionary:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\njjj = {'chuck':1, 'fred':42, 'jan':100}\n\nprint(list(jjj))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['chuck', 'fred', 'jan']\n```\n:::\n:::\n\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nprint(jjj.keys())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_keys(['chuck', 'fred', 'jan'])\n```\n:::\n:::\n\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nprint(jjj.values())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_values([1, 42, 100])\n```\n:::\n:::\n\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\n#retrieve a list of key value pairs, each stored in what is called a  tuple\nprint(jjj.items())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ndict_items([('chuck', 1), ('fred', 42), ('jan', 100)])\n```\n:::\n:::\n\n\n## Looping using the items method\n\n- We loop through the key-value pairs in a dictionary using two iteration variables\n- Each iteration, the first variable is the key and the second variable is the corresponding value for the key\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\njjj = {'chuck':1, 'fred':42, 'jan':100}\n\n#use to iteration variables, aa and bb\nfor aa,bb in jjj.items():\n    print(aa, aa)\n\nprint('')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nchuck chuck\nfred fred\njan jan\n\n```\n:::\n:::\n\n\n## Count words in a text file\n\nThe working code can be found in `code/count_words.py`\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\n#name = input('Enter file: ')\nname = '../data/words.txt'\nhandle = open(name)\n\ncounts = dict()\n\n#create a dictionary to count the words\nfor line in handle:\n    words = line.split()\n    for word in words:\n        counts[word] = counts.get(word , 0) + 1\n\nbigcount = None\nbigword = None\n\n#go through the dictionary counts and identify the item with the most counts\nfor word, count in counts.items():\n    if bigcount is None or count > bigcount:\n        bigword = word\n        bigcount = count\n\nprint(bigword, bigcount)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nto 16\n```\n:::\n:::\n\n\n## Assignment 9.4\n\nWrite a program to read through the mbox-short.txt and figure out who has sent the greatest number of mail messages.\n\nThe program looks for 'From ' lines and takes the second word of those lines as the person who sent the mail. \n\nThe program creates a Python dictionary that maps the sender's mail address to a count of the number of times they appear in the file. \n\nAfter the dictionary is produced, the program reads through the dictionary using a maximum loop to find the most prolific committer.\n\nCode can be found in `code/assignment_9_4.py`\n\nNotice: This returns an error with reticulate but runs fine during the rendering.\nThe problem is that one line is seen as `line == '[]'` and nothing helps while trying to remove it\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\nname = '../data/mbox-short.txt'\nhandle = open(name)\n\nsenders_dict = dict()\n\nbigcount = None\nbigword = None\n\nfor line in handle:\n    line = line.rstrip()\n    if not line.startswith('From '):\n        continue\n\n    #generate a dict of senders\n    mail = line.split()[1]\n    senders_dict[mail] = senders_dict.get(mail, 0) + 1\n\n    #identify the most prolific committer\n    for key, value in senders_dict.items():\n        if bigcount is None or value > bigcount:\n            bigcount = value\n            bigword = key\n\nprint(bigword, bigcount)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncwen@iupui.edu 5\n```\n:::\n:::\n\n\n",
    "supporting": [
      "4_dictionaries_files/figure-pdf"
    ],
    "filters": []
  }
}